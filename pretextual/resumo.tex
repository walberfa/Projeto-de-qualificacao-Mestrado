\setlength{\absparsep}{18pt} % ajusta o espaçamento dos parágrafos do resumo
\begin{resumo}
 Para entrar em estado de execução, programas podem solicitar ao sistema operacional o espaço de memória que necessitam. A eles é dado espaço de memória virtual, cujos endereços são chamados de páginas. Quem gerencia essas páginas e converte endereços virtuais em endereços físicos da memória é o \textit{Memory Manegement Unit} (MMU). Dentro do MMU, fica a \textit{translation lookaside buffer} (TLB), uma cache que armazena apenas as páginas mais referenciadas. As entradas de uma TLB podem ser afetadas por interferências nas células de memória, conhecidas como \textit{Multiple Cell Upset} (MCU). Uma das consequências causadas pelos MCUs em TLBs é o aumento da necessidade de tratamento de falta de página, o que interfere diretamente no desempenho do sistema. No entanto, falhas ainda mais graves podem acontecer, como o congelamento do sistema ou corrupção de dados. Diferentes métodos para proteger TLBs foram propostos ao longo dos anos, no entanto, muitas dessas soluções requerem mais espaço de memória ou poder computacional, sobrecarregando o sistema. Nesse contexto, códigos de detecção de erros que se apropriam do princípio da localidade e que não adicionam bits de redundância, permitem reduzir ou até mesmo evitar o impacto destas falhas. Essa codificação envolve manipular os bits do endereço de memória, aumentando a distância Hamming entre endereços próximos através do cálculo de paridade entre os bits pares e ímpares, individualmente. O resultado destas paridades é alocado nos dois bits mais significativos (MSBs) do endereço, enquanto os outros bits permanecem inalterados. Este trabalho propõe explorar ainda mais o princípio da localidade, fazendo o cálculo das paridades com parcelas menores de bits ao invés de usar toda a palavra. Este método propaga o erro apenas dos bits menos significativos, que é onde a ocorrência de erros pode gerar falhas mais graves. Foram propostos quatro cenários: calculando a paridade entre os 4, 8, 12 e 16 bits menos significativos, num endereço com 32 bits. Foram realizadas 10 mil iterações para cada tipo de falha (única, dupla e tripla adjacente) nos experimentos com injeção de falha pseudoaleatória em cada cenário, inseridas em diferentes posições e endereços a cada execução. O \textit{benchmark} era composto pelos \textit{traces} de memória de algoritmos de aplicações reais. O simulador de TLB implementado apresenta o LRU como política de substituição e 8 posições de memória. Após os experimentos, ficou indicado que proteger os bits menos significativos no cálculo  de paridade apresentou resultados semelhantes a proteger a palavra toda, ocupando até 20\%\ de portas XOR. Além disso, ainda reduz bastante as falhas protegendo apenas os 4-LSBs, confirmando que é possível proteger a TLB ocupando menos área na síntese do circuito. 

 \textbf{Palavras-chave}: códigos de correção de erros. \textit{multiple cell upsets. translation lookaside buffer}.
\end{resumo}